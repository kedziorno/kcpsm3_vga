CONSTANT X_ROW, 16;
CONSTANT Y_COL, 17;
CONSTANT COLOR, 20;

;Name the registers - alias
NAMEREG s0, tmp
NAMEREG s1, x_msb
NAMEREG s2, x_lsb
NAMEREG s3, y_msb
NAMEREG s4, y_lsb
NAMEREG s5, z_msb
NAMEREG s6, z_lsb
NAMEREG s7, LUT_pnt
NAMEREG s8, tmp_H
NAMEREG s9, tmp_L
NAMEREG sA, tmp_H2
NAMEREG sB, tmp_L2
NAMEREG sC, i
NAMEREG sD, k
NAMEREG sE, temp_z_lsb
NAMEREG sF, temp_z_msb

;Declare Constant
;CONSTANT inPrt_H, 01
;CONSTANT inPrt_L, 02
;CONSTANT prtX_H, 04
;CONSTANT prtX_L, 08
;CONSTANT prtY_H, 10
;CONSTANT prtY_L, 20
CONSTANT DEBUG_SIN, 01
CONSTANT DEBUG_COS, 02
CONSTANT DEBUG_THETA, 03

CONSTANT m_x_lsb, 3f
CONSTANT m_x_msb, 3e
CONSTANT m_y_lsb, 3d
CONSTANT m_y_msb, 3c
CONSTANT M_X_ROW, 3b
CONSTANT M_Y_COL, 3a
CONSTANT M_QUADRANT, 39

CONSTANT testPort, 40
CONSTANT NEG_SGN, 80
CONSTANT EIGHT, 08
CONSTANT NINE, 09
CONSTANT ONE, 01
CONSTANT ZERO, 00

; make_cordic_params.py `echo "(180/3.1415)*256" | bc -l` 16 1
; make_cordic_params.py 58 8 1
; 1rad ~ 57.324840 (180/3.14.15)
; 1rad * 256
;Scratchpad RAM initalize
;use Reg tmp for load and store values
LOAD tmp,  00 ;LUT: 0.605469_msb
STORE tmp, 00 ;loc
LOAD tmp,  9B ;LUT: 0.605469_lsb
STORE tmp, 01 ;loc

LOAD tmp,  2D ;LUT: 45.000000 msb
STORE tmp, 02 ;loc
LOAD tmp,  00 ;LUT: 45.000000_lsb
STORE tmp, 03 ;loc

LOAD tmp,  1A ;LUT: 26.5625_msb
STORE tmp, 04 ;loc
LOAD tmp,  90 ;LUT: 26.5625_lsb
STORE tmp, 05 ;loc

LOAD tmp,  0E ;LUT: 14.035156_msb
STORE tmp, 06 ;loc
LOAD tmp,  09 ;LUT: 14.035156_lsb
STORE tmp, 07 ;loc

LOAD tmp,  07 ;LUT: 7.125000_msb
STORE tmp, 08 ;loc
LOAD tmp,  20 ;LUT: 7.125000_lsb
STORE tmp, 09 ;loc

LOAD tmp,  03 ;LUT: 3.574219_msb
STORE tmp, 0A ;loc
LOAD tmp,  93 ;LUT: 3.574219_lsb
STORE tmp, 0B ;loc

LOAD tmp,  01 ;LUT: 1.792969_msb
STORE tmp, 0C ;loc
LOAD tmp,  CB ;LUT: 1.792969_lsb
STORE tmp, 0D ;loc

LOAD tmp,  00 ;LUT: 0.894531_msb
STORE tmp, 0E ;loc
LOAD tmp,  E5 ;LUT: 0.894531_lsb
STORE tmp, 0F ;loc

LOAD tmp,  00 ;LUT: 0.445313_msb
STORE tmp, 10 ;loc
LOAD tmp,  72 ;LUT: 0.445313_lsb
STORE tmp, 11 ;loc

LOAD tmp,  00 ;LUT: 0.226563_msb
STORE tmp, 12 ;loc
LOAD tmp,  3A ;LUT: 0.226563_lsb
STORE tmp, 13 ;loc

LOAD temp_z_msb, 00
LOAD temp_z_lsb, 00

loop:
;Input the rotation value from FPGA MUXes
ADD temp_z_lsb, ff
ADDCY temp_z_msb, 00

OUTPUT temp_z_lsb, DEBUG_THETA
OUTPUT temp_z_msb, DEBUG_THETA

; error correction
;COMPARE z_msb, 5A
;JUMP Z, case_90
;COMPARE z_msb, 00
;JUMP Z, case_0

CONSTANT CORDIC_BASE_LO, 00;
CONSTANT CORDIC_BASE_HI, 01
CONSTANT Quad2Boundary_LO, 00;
CONSTANT Quad2Boundary_HI, 02;
CONSTANT Quad3Boundary_LO, 00;
CONSTANT Quad3Boundary_HI, 03;

QUAD1:
LOAD y_msb, CORDIC_BASE_HI
LOAD x_lsb, CORDIC_BASE_LO
LOAD x_msb, temp_z_msb
LOAD tmp, temp_z_lsb
CALL compare_16
COMPARE y_lsb, 04; >
JUMP Z, QUAD2
LOAD tmp, 01
STORE tmp, M_QUADRANT
LOAD z_lsb, temp_z_lsb
LOAD z_msb, temp_z_msb

QUAD2:
LOAD y_msb, Quad2Boundary_HI
LOAD x_lsb, Quad2Boundary_LO
LOAD x_msb, temp_z_msb
LOAD tmp, temp_z_lsb
CALL compare_16
COMPARE y_lsb, 04; >
JUMP Z, QUAD3
LOAD tmp, 02
STORE tmp, M_QUADRANT
LOAD y_msb, Quad2Boundary_HI
LOAD x_lsb, Quad2Boundary_LO
LOAD x_msb, temp_z_msb
LOAD tmp, temp_z_lsb
CALL subtract_16
LOAD z_lsb, tmp
LOAD z_msb, x_msb

QUAD3:
LOAD y_msb, Quad3Boundary_HI
LOAD x_lsb, Quad3Boundary_LO
LOAD x_msb, temp_z_msb
LOAD tmp, temp_z_lsb
CALL compare_16
COMPARE y_lsb, 04; >
JUMP Z, QUAD4
LOAD tmp, 03
STORE tmp, M_QUADRANT
LOAD y_msb, temp_z_msb
LOAD x_lsb, temp_z_lsb
LOAD x_msb, Quad3Boundary_HI
LOAD tmp, Quad3Boundary_LO
CALL subtract_16
LOAD z_lsb, tmp
LOAD z_msb, x_msb

QUAD4:
LOAD tmp, 04
STORE tmp, M_QUADRANT
LOAD tmp, temp_z_lsb
XOR tmp, FF
ADD tmp, 01
LOAD temp_z_lsb, tmp
LOAD tmp, temp_z_msb
XOR tmp, FF
ADDCY tmp, 00
LOAD temp_z_msb, tmp
LOAD z_lsb, temp_z_lsb
LOAD z_msb, temp_z_msb


init:
;initialize registers
LOAD LUT_pnt, 00
FETCH x_msb, (LUT_pnt)

ADD LUT_pnt, 01
FETCH x_lsb, (LUT_pnt)

LOAD i, FF

next1:

;OUTPUT z_lsb, DEBUG_THETA
;OUTPUT z_msb, DEBUG_THETA

ADD i, 01
;OUTPUT i, testPort

;prepare registers for subroutines
LOAD tmp_H, x_msb
LOAD tmp_L, x_lsb
LOAD tmp_H2, y_msb
LOAD tmp_L2, y_lsb

LOAD k, i

shift:
COMPARE k, ZERO
JUMP  Z, next2

;divide by 2 (shift one to the right)
SRX tmp_H
SRA tmp_L
SRX tmp_H2
SRA tmp_L2

SUB k, 01
JUMP shift

next2:
COMPARE i, NINE
JUMP Z, out_rslt

;check rotation sign
LOAD tmp, z_msb
AND tmp, NEG_SGN

;COMPARE z msb with NEG SGN- -
;TEST tmp, NEG_SGN
JUMP NZ, neg_case

;else Z_msb is positive--> continue

pos_case:
;X[i=O]
SUB x_lsb, tmp_L2
SUBCY x_msb, tmp_H2

;Y[i=O]
ADD y_lsb, tmp_L
ADDCY y_msb, tmp_H

;Z[i+l]
ADD LUT_pnt, 01
FETCH tmp_H, (LUT_pnt)
ADD LUT_pnt, 01
FETCH tmp_L,(LUT_pnt)
SUB z_lsb, tmp_L
SUBCY z_msb, tmp_H

JUMP next1

neg_case:

;X[i=O]
ADD x_lsb, tmp_L2
ADDCY x_msb, tmp_H2

;Y[i=O]
SUB y_lsb, tmp_L
SUBCY y_msb, tmp_H

;Z[i+l]
ADD LUT_pnt, 01
FETCH tmp_H, (LUT_pnt)
ADD LUT_pnt, 01
FETCH tmp_L,(LUT_pnt)
ADD z_lsb, tmp_L
ADDCY z_msb, tmp_H

JUMP next1

case_0:
LOAD x_msb, 01
LOAD x_lsb, 00
LOAD y_msb, 00
LOAD y_lsb, 00
JUMP out_rslt

case_90:
LOAD x_msb, 00
LOAD x_lsb, 00
LOAD y_msb, 01
LOAD y_lsb, 00
JUMP out_rslt
 
out_rslt:
; todo compensate ? K (0.60725*256 ~ 155.45)

QUADR1C:
FETCH tmp, M_QUADRANT
COMPARE tmp, 01
JUMP NZ, QUADR4C
LOAD tmp, x_lsb
XOR tmp, FF
ADD tmp, 01
LOAD x_lsb, tmp
LOAD tmp, x_msb
XOR tmp, FF
ADDCY tmp, 00
LOAD x_msb, tmp
JUMP DRAW

QUADR4C:
FETCH tmp, M_QUADRANT
COMPARE tmp, 04
JUMP NZ, QUADR1S
LOAD tmp, x_lsb
XOR tmp, FF
ADD tmp, 01
LOAD x_lsb, tmp
LOAD tmp, x_msb
XOR tmp, FF
ADDCY tmp, 00
LOAD x_msb, tmp
JUMP DRAW

QUADR1S:
FETCH tmp, M_QUADRANT
COMPARE tmp, 01
JUMP NZ, QUADR4S
LOAD tmp, y_lsb
XOR tmp, FF
ADD tmp, 01
LOAD y_lsb, tmp
LOAD tmp, y_msb
XOR tmp, FF
ADDCY tmp, 00
LOAD y_msb, tmp
JUMP DRAW

QUADR4S:
FETCH tmp, M_QUADRANT
COMPARE tmp, 04
JUMP NZ, DRAW
LOAD tmp, y_lsb
XOR tmp, FF
ADD tmp, 01
LOAD y_lsb, tmp
LOAD tmp, y_msb
XOR tmp, FF
ADDCY tmp, 00
LOAD y_msb, tmp
JUMP DRAW

DRAW:
STORE x_lsb, m_x_lsb
STORE x_msb, m_x_msb
STORE y_lsb, m_y_lsb
STORE y_msb, m_y_msb

CONSTANT SCALER, 04; approximate x4-x20

FETCH y_msb, m_x_msb;
FETCH x_lsb, m_x_lsb;
OUTPUT x_lsb, DEBUG_COS;
OUTPUT y_msb, DEBUG_COS;
LOAD x_msb, 00;
LOAD tmp, SCALER;
CALL divide_16;
;   s7,s6 - Q
;   s5,s4 - R
LOAD y_msb, 00;
LOAD x_lsb, z_lsb;
LOAD x_msb, 00;
LOAD tmp, 28;
CALL adder_16
STORE tmp, M_X_ROW;

FETCH y_msb, m_y_msb;
FETCH x_lsb, m_y_lsb;
OUTPUT x_lsb, DEBUG_SIN;
OUTPUT y_msb, DEBUG_SIN;
LOAD x_msb, 00;
LOAD tmp, SCALER;
CALL divide_16;
;   s7,s6 - Q
;   s5,s4 - R
LOAD y_msb, 00;
LOAD x_lsb, z_lsb;
LOAD x_msb, 00;
LOAD tmp, 28;
CALL adder_16
STORE tmp, M_Y_COL;

FETCH tmp, M_X_ROW;
OUTPUT tmp, X_ROW; 
FETCH tmp, M_Y_COL;
OUTPUT tmp, Y_COL; 
LOAD tmp, 3F;
OUTPUT tmp, COLOR; 

JUMP loop

adder_16:
_adder_16_start:                  ;
                  ADD    tmp , x_lsb  ; add LSBs
                  ADDCY  x_msb , y_msb  ; add MSBs
_adder_16_end:                    ;
                  RETURN          ; keep result in x_msb and tmp

divide_16:
_divide_16_start:                               ;
                  LOAD    z_msb , y_msb               ; R := N
                  LOAD    y_lsb , x_lsb               ;
                  LOAD    LUT_pnt , 00               ; Q := 0
                  LOAD    z_lsb , 00               ;
_divide_16_loop:
                  COMPARE y_lsb , tmp               ; while R >= D do
                  SUBCY   x_msb , 00               ;
                  COMPARE z_msb , x_msb               ;
                  JUMP     C , _divide_16_end   ; <
                  SUB     y_lsb , tmp               ; R := R âˆ’ D
                  SUBCY   z_msb , x_msb               ;
                  ADD     z_lsb , 01               ; Q := Q + 1
                  ADDCY   LUT_pnt , 00               ;
                  JUMP         _divide_16_loop  ;
_divide_16_end:                                 ;
                  RETURN                        ;

compare_16:
_compare_16_start:                                      ;
                      COMPARE y_msb , x_msb                   ;
                      JUMP     C , _compare_16_less     ;
                      JUMP     Z , _compare_16_equal_hi ;
                      JUMP         _compare_16_more     ;
_compare_16_equal_hi:                                   ;
                      COMPARE x_lsb , tmp                   ;
                      JUMP     C , _compare_16_less     ;
                      JUMP    NZ , _compare_16_more     ;
                      JUMP         _compare_16_equal    ;
_compare_16_less:                                       ; s3,s2 < s1,s0
                      LOAD    y_lsb , 01                   ;
                      JUMP         _compare_16_end      ;
_compare_16_equal:                                      ; s3,s2 = s1,s0
                      LOAD    y_lsb , 02                   ;
                      JUMP         _compare_16_end      ;
_compare_16_more:                                       ; s3,s2 > s1,s0
                      LOAD    y_lsb , 04                   ;
_compare_16_end:                                        ;
                      RETURN                            ;

subtract_16:
_subtract_16_start:               ;
                    SUB   tmp , x_lsb ;
                    SUBCY x_msb , y_msb ;
_subtract_16_end:                 ;
                    RETURN        ;


