; cordic based on
;   https://raw.githubusercontent.com/brodzik/arko-project-1/refs/heads/master/prototypes/cordic.asm
;   https://scholarworks.calstate.edu/downloads/7d278z14r (Author : Sara Nazemzadeh).
;   https://remcycles.net/blog/cordic.html
;

NAMEREG s9, t0;
NAMEREG sA, t1;
NAMEREG sB, t2;
NAMEREG sC, t3;
NAMEREG sD, t4;
NAMEREG sE, t5;
NAMEREG sF, A;

; OUTPUT VGA
CONSTANT X_ROW, 16;
CONSTANT Y_COL, 17;
CONSTANT COLOR, 20;

; OUTPUT DEBUG
CONSTANT DEBUG_SIN, 01;
CONSTANT DEBUG_COS, 02;
CONSTANT DEBUG_THETA, 03;
CONSTANT PORT_4, 04;
CONSTANT PORT_5, 05;
CONSTANT PORT_6, 06;
CONSTANT PORT_7, 07;
CONSTANT PORT_8, 08;

; CONSTANTS
CONSTANT ZERO, 00;
CONSTANT C_K_INV, 4D;
CONSTANT C_SIGN_NEG, 80
CONSTANT C_QUAD1, 01;
CONSTANT C_QUAD2, 02;
CONSTANT C_QUAD3, 03;
CONSTANT C_QUAD4, 04;
CONSTANT C_THETA_LO, 00;
CONSTANT C_THETA_HI, 00;
CONSTANT C_CORDIC_BASE_LO, 5a;
CONSTANT C_CORDIC_BASE_HI, 00;
CONSTANT C_Q2B_LO, b4;
CONSTANT C_Q2B_HI, 00;
CONSTANT C_Q3B_LO, 0e;
CONSTANT C_Q3B_HI, 01;
CONSTANT C_THETA_STEP_LO, 01;
CONSTANT C_THETA_STEP_HI, 00;
CONSTANT C_ANGLE_360_LO, 68;
CONSTANT C_ANGLE_360_HI, 01;
CONSTANT C_ROM_ANGLES_STEP, 01;
CONSTANT C_ROM_ANGLES_START, 13;

; MEMORY ADDRESSESS
CONSTANT M_THETA_LO, 09;
CONSTANT M_THETA_HI, 08;
CONSTANT M_THETA_TEMP_LO, 3d;
CONSTANT M_THETA_TEMP_HI, 3e;
CONSTANT M_ROM_ANGLES_LEN, 10;
CONSTANT M_QUADRANT, 24;
CONSTANT M_ANGLE, 3b;
CONSTANT M_X_SHIFT, 33;
CONSTANT M_Y_SHIFT, 35;
CONSTANT M_X, 37;
CONSTANT M_Y, 39;
CONSTANT M_COSINE, 0B;
CONSTANT M_SINE, 0D;
CONSTANT M_X_ROW, 22
CONSTANT M_Y_COL, 23

rom_angles_8_bit:
_rom_angles_8_bit_start:
LOAD A, C_ROM_ANGLES_START;
_rom_angles_8_bit_variables:
LOAD t0,    20;
CALL _rom_angles_8_bit_store;
LOAD t0,    13;
CALL _rom_angles_8_bit_store;
LOAD t0,    0a;
CALL _rom_angles_8_bit_store;
LOAD t0,    05;
CALL _rom_angles_8_bit_store;
LOAD t0,    03;
CALL _rom_angles_8_bit_store;
LOAD t0,    01;
CALL _rom_angles_8_bit_store;
LOAD t0,    01;
CALL _rom_angles_8_bit_store;
LOAD t0,    00;
CALL _rom_angles_8_bit_store;
JUMP _rom_angles_8_bit_end;
_rom_angles_8_bit_store:
STORE t0, (A);
ADD A, C_ROM_ANGLES_STEP;
RETURN;
_rom_angles_8_bit_end:
SUB A, C_ROM_ANGLES_START;
STORE A, M_ROM_ANGLES_LEN;

initialize_theta:
LOAD A, C_THETA_HI;
STORE A, M_THETA_TEMP_HI;
LOAD A, C_THETA_LO;
STORE A, M_THETA_TEMP_LO;

cordic_main:

initialize_k:
LOAD A, ZERO;
STORE A, M_Y;
STORE A, M_X_SHIFT;
STORE A, M_Y_SHIFT;
LOAD A, C_K_INV;
STORE A, M_X;

cordic_initialize:
LOAD t0, ZERO;
LOAD t1, C_ROM_ANGLES_START;
FETCH t2, M_ROM_ANGLES_LEN;

add_theta_step:
FETCH A, M_THETA_TEMP_LO;
OUTPUT A, DEBUG_THETA;
ADD A, C_THETA_STEP_LO;
STORE A, M_THETA_TEMP_LO;
FETCH A, M_THETA_TEMP_HI;
OUTPUT A, DEBUG_THETA;
ADDCY A, C_THETA_STEP_HI;
STORE A, M_THETA_TEMP_HI;

compare_theta_360:
FETCH A, M_THETA_TEMP_LO;
COMPARE A, C_ANGLE_360_LO;
JUMP Z, _compare_theta_360_lo_equal;
JUMP check_quadrants;
_compare_theta_360_lo_equal:
FETCH A, M_THETA_TEMP_HI;
COMPARE A, C_ANGLE_360_HI;
JUMP Z, END;

check_quadrants:

Q1:
FETCH s3, M_THETA_TEMP_HI;
FETCH s2, M_THETA_TEMP_LO;
LOAD s1, C_CORDIC_BASE_HI;
LOAD s0, C_CORDIC_BASE_LO;
CALL compare_16;
COMPARE s4, 01; <
JUMP Z, _Q1;
JUMP Q2; >=
_Q1:
LOAD A, C_QUAD1;
STORE A, M_QUADRANT;
OUTPUT A, PORT_4;
FETCH A, M_THETA_TEMP_LO;
STORE A, M_THETA_LO;
FETCH A, M_THETA_TEMP_HI;
STORE A, M_THETA_HI;

FETCH A, M_THETA_LO;
OUTPUT A, PORT_7;
FETCH A, M_THETA_HI;
OUTPUT A, PORT_8;
JUMP cordic_loop;

Q2:
FETCH s3, M_THETA_TEMP_HI;
FETCH s2, M_THETA_TEMP_LO;
LOAD s1, C_Q2B_HI;
LOAD s0, C_Q2B_LO;
CALL compare_16;
COMPARE s4, 01; <
JUMP Z, _Q2;
JUMP Q3; >=
_Q2:
LOAD A, C_QUAD2;
STORE A, M_QUADRANT;
OUTPUT A, PORT_4;
FETCH s3, M_THETA_TEMP_HI;
FETCH s2, M_THETA_TEMP_LO;
LOAD s1, C_Q2B_HI;
LOAD s0, C_Q2B_LO;
CALL subtract_16;
STORE s1, M_THETA_HI;
STORE s0, M_THETA_LO;

FETCH A, M_THETA_LO;
OUTPUT A, PORT_7;
FETCH A, M_THETA_HI;
OUTPUT A, PORT_8;
JUMP cordic_loop;

Q3:
FETCH s3, M_THETA_TEMP_HI;
FETCH s2, M_THETA_TEMP_LO;
LOAD s1, C_Q3B_HI;
LOAD s0, C_Q3B_LO;
CALL compare_16;
COMPARE s4, 01; <
JUMP Z, _Q3;
JUMP Q4; >=
_Q3:
LOAD A, C_QUAD3;
STORE A, M_QUADRANT;
OUTPUT A, PORT_4;
LOAD s3, C_Q2B_HI;
LOAD s2, C_Q2B_LO;
FETCH s1, M_THETA_TEMP_HI;
FETCH s0, M_THETA_TEMP_LO;
CALL subtract_16;
STORE s1, M_THETA_HI;
STORE s0, M_THETA_LO;

FETCH A, M_THETA_LO;
OUTPUT A, PORT_7;
FETCH A, M_THETA_HI;
OUTPUT A, PORT_8;
JUMP cordic_loop;

Q4:
LOAD A, C_QUAD4;
STORE A, M_QUADRANT;
OUTPUT A, PORT_4;
LOAD s3, C_Q3B_HI;
LOAD s2, C_Q3B_LO;
FETCH s1, M_THETA_TEMP_HI;
FETCH s0, M_THETA_TEMP_LO;
CALL subtract_16;
STORE s1, M_THETA_HI;
STORE s0, M_THETA_LO;

FETCH A, M_THETA_LO;
OUTPUT A, PORT_7;
FETCH A, M_THETA_HI;
OUTPUT A, PORT_8;

cordic_loop:
COMPARE t0, t2;
JUMP Z, cordic_end;

x_shift_i:
FETCH A, M_X;
LOAD t3, t0;
COMPARE t3, ZERO;
JUMP Z, _x_shift_i_store;
_x_shift_i_right_1:
SRX A;
SUB t3, 01;
JUMP NZ, _x_shift_i_right_1;
_x_shift_i_store:
STORE A, M_X_SHIFT;

y_shift_i:
FETCH A, M_Y;
LOAD t3, t0;
COMPARE t3, ZERO;
JUMP Z, _y_shift_i_store;
_y_shift_i_right_1:
SRX A;
SUB t3, 01;
JUMP NZ, _y_shift_i_right_1;
_y_shift_i_store:
STORE A, M_Y_SHIFT;

load_rom_angle:
LOAD A, t1;
FETCH A, (A);
STORE A, M_ANGLE;

theta_less_than_zero:
FETCH A, M_THETA_HI;
AND A, C_SIGN_NEG;
COMPARE A, C_SIGN_NEG;
JUMP Z, sign_negative;

sign_positive:

x_minus_y_shift_pos:
FETCH A, M_X;
FETCH t3, M_Y_SHIFT;
SUB A, t3;
STORE A, M_X;

y_plus_x_shift_pos:
FETCH A, M_Y;
FETCH t3, M_X_SHIFT;
ADD A, t3;
STORE A, M_Y;

theta_minus_angle_pos:
LOAD s3, ZERO;
FETCH s2, M_ANGLE;
FETCH s1, M_THETA_HI;
FETCH s0, M_THETA_LO;
CALL subtract_16;
STORE s0, M_THETA_LO;
STORE s1, M_THETA_HI;

JUMP sign_end;

sign_negative:

x_plus_y_shift_neg:
FETCH A, M_X;
FETCH t3, M_Y_SHIFT;
ADD A, t3;
STORE A, M_X;

y_minus_x_shift_neg:
FETCH A, M_Y;
FETCH t3, M_X_SHIFT;
SUB A, t3;
STORE A, M_Y;

theta_plus_angle_neg:
LOAD s3, ZERO;
FETCH s2, M_ANGLE;
FETCH s1, M_THETA_HI;
FETCH s0, M_THETA_LO;
CALL adder_16;
STORE s0, M_THETA_LO;
STORE s1, M_THETA_HI;

sign_end:
ADD t0, 01;
ADD t1, 01;

jump cordic_loop;

cordic_end:

QR1:

QR2:
FETCH A, M_QUADRANT;
COMPARE A, C_QUAD2;
JUMP Z, _QR2;
JUMP QR3;
_QR2:
FETCH A, M_X;
XOR A, FF;
ADD A, 01;
STORE A, M_X;
JUMP DRAW;

QR3:
FETCH A, M_QUADRANT;
COMPARE A, C_QUAD3;
JUMP Z, _QR3;
JUMP QR4;
_QR3:
FETCH A, M_X;
XOR A, FF;
ADD A, 01;
STORE A, M_X;
FETCH A, M_Y;
XOR A, FF;
ADD A, 01;
STORE A, M_Y;
JUMP DRAW;

QR4:
FETCH A, M_QUADRANT;
COMPARE A, C_QUAD4;
JUMP Z, _QR4;
JUMP DRAW;
_QR4:
FETCH A, M_Y;
XOR A, FF;
ADD A, 01;
STORE A, M_Y;
JUMP DRAW;

DRAW:

FETCH A, M_Y;
OUTPUT A, DEBUG_SIN;
SRX A;
SRX A;
ADD A, 28;
LOAD t0, A;

FETCH A, M_X;
OUTPUT A, DEBUG_COS;
SRX A;
SRX A;
ADD A, 28;
LOAD t1, A;

CALL draw_pixel;

JUMP cordic_main;

draw_pixel:
OUTPUT t0, X_ROW; 
OUTPUT t1, Y_COL; 
LOAD A, 3F;
OUTPUT A, COLOR; 
RETURN;

subtract_16:
; Figure 3-9: 16-Bit Subtraction Using SUB and SUBCY Instructions
;   ug129.pdf
; INPUT  :
;   s3 = subtrahend (a) HI
;   s2 = subtrahend (a) LO
;   s1 = minuend (b) HI
;   s0 = minuend (b) LO
; OUTPUT :
;   s1 = difference MSB
;   s0 = difference LSB
; INFO   :
;
_subtract_16_start:               ;
                    SUB   s0 , s2 ;
                    SUBCY s1 , s3 ;
_subtract_16_end:                 ;
                    RETURN        ;

adder_16:
; Figure 3-8: 16-Bit Addition Using ADD and ADDCY Instructions
;   ug129.pdf
; INPUT  :
;   s3 = addition (a) HI
;   s2 = addition (a) LO
;   s1 = addition (b) HI
;   s0 = addition (b) LO
; OUTPUT :
;   s1 = product MSB
;   s0 = product LSB
; INFO   :
;
_adder_16_start:                  ;
                  ADD    s0 , s2  ; add LSBs
                  ADDCY  s1 , s3  ; add MSBs
_adder_16_end:                    ;
                  RETURN          ; keep result in s1 and s0

compare_16:
; INPUT  :
;   - A [s3,s2]
;   - B [s1,s0]
; OUTPUT :
;   - A < B - s4 = 0x01
;   - A = B - s4 = 0x02
;   - A > B - s4 = 0x04
; INFO   :
;
_compare_16_start:                                      ;
                      COMPARE s3 , s1                   ;
                      JUMP     C , _compare_16_less     ;
                      JUMP     Z , _compare_16_equal_hi ;
                      JUMP         _compare_16_more     ;
_compare_16_equal_hi:                                   ;
                      COMPARE s2 , s0                   ;
                      JUMP     C , _compare_16_less     ;
                      JUMP    NZ , _compare_16_more     ;
                      JUMP         _compare_16_equal    ;
_compare_16_less:                                       ; s3,s2 < s1,s0
                      LOAD    s4 , 01                   ;
                      JUMP         _compare_16_end      ;
_compare_16_equal:                                      ; s3,s2 = s1,s0
                      LOAD    s4 , 02                   ;
                      JUMP         _compare_16_end      ;
_compare_16_more:                                       ; s3,s2 > s1,s0
                      LOAD    s4 , 04                   ;
_compare_16_end:                                        ;
                      RETURN                            ;

END:
  JUMP END;


