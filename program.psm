CONSTANT X_ROW, 16;
CONSTANT Y_COL, 17;
CONSTANT COLOR, 20;
CONSTANT DEBUG_SIN_1, 01;
CONSTANT DEBUG_COS_1, 02;
CONSTANT DEBUG_SIN_2, 03;
CONSTANT DEBUG_COS_2, 04;
CONSTANT DEBUG_THETA, 05;

CONSTANT ANGLE_16_HI,00;
CONSTANT ANGLE_16_LO,01;
CONSTANT COSINE_16_HI,02;
CONSTANT COSINE_16_LO,03;
CONSTANT SINE_16_HI,04;
CONSTANT SINE_16_LO,05;
CONSTANT K,06;
CONSTANT XTMP_0,07;
CONSTANT XTMP_1,08;
CONSTANT YTMP_0,09;
CONSTANT YTMP_1,0A;
CONSTANT X_0,0B;
CONSTANT X_1,0C;
CONSTANT Y_0,0D;
CONSTANT Y_1,0E;
CONSTANT Z_0,0F;
CONSTANT Z_1,10;
CONSTANT E_0,11;
CONSTANT E_1,12;

NAMEREG s0, A;
NAMEREG s8, DPTR;
NAMEREG s7, R0;
NAMEREG s6, R1;
NAMEREG s5, R2;
NAMEREG s4, R3;

CONSTANT E_00_START, 13;
CONSTANT E_00_END, 2E;
CONSTANT E_00_LEN, 2f;

E_00:
LOAD A,22;
STORE A,13;
LOAD A,19;
STORE A,14;

LOAD A,D6;
STORE A,15;
LOAD A,0E;
STORE A,16;

LOAD A,D7;
STORE A,17;
LOAD A,07;
STORE A,18;

LOAD A,FB;
STORE A,19;
LOAD A,03;
STORE A,1A;

LOAD A,FF;
STORE A,1B;
LOAD A,01;
STORE A,1C;

LOAD A,00;
STORE A,1D;
LOAD A,01;
STORE A,1E;

LOAD A,80;
STORE A,1F;
LOAD A,00;
STORE A,20;

LOAD A,40;
STORE A,21;
LOAD A,00;
STORE A,22;

LOAD A,20;
STORE A,23;
LOAD A,00;
STORE A,24;

LOAD A,10;
STORE A,25;
LOAD A,00;
STORE A,26;

LOAD A,08;
STORE A,27;
LOAD A,00;
STORE A,28;

LOAD A,04;
STORE A,29;
LOAD A,00;
STORE A,2A;

LOAD A,02;
STORE A,2B;
LOAD A,00;
STORE A,2C;

LOAD A,01;
STORE A,2D;
LOAD A,00;
STORE A,2E;

CONSTANT TEMP_ANGLE_16_LO, 30;
CONSTANT TEMP_ANGLE_16_HI, 31;

ANGLE_16:
LOAD A,6F; INITIALIZE X[0]
STORE A,X_0;
LOAD A,13;
STORE A,X_1;
LOAD A,00; INITIALIZE Y[0]
STORE A,Y_0;
LOAD A,00;
STORE A,Y_1;

LOAD R2, 00;

LOAD A, E_00_END;
LOAD s1, E_00_START;
SUB A, s1;
ADD A, 01;
SR0 A;
STORE A, E_00_LEN;

LOAD A, 00;
STORE A, TEMP_ANGLE_16_LO;
LOAD A, 00;
STORE A, TEMP_ANGLE_16_HI;

main:
LOAD A, 09;
STORE A, TEMP_ANGLE_16_LO;
LOAD A, 8c;
STORE A, TEMP_ANGLE_16_HI;
CALL cordic1;

LOAD A, 8c;
STORE A, TEMP_ANGLE_16_LO;
LOAD A, 09;
STORE A, TEMP_ANGLE_16_HI;
CALL cordic1;

LOAD A, c9;
STORE A, TEMP_ANGLE_16_LO;
LOAD A, 10;
STORE A, TEMP_ANGLE_16_HI;
CALL cordic1;

LOAD A, 10;
STORE A, TEMP_ANGLE_16_LO;
LOAD A, c9;
STORE A, TEMP_ANGLE_16_HI;
CALL cordic1;

JUMP USER_CODE_END;

cordic1:
FETCH A, TEMP_ANGLE_16_LO;
STORE A, ANGLE_16_LO;
OUTPUT A, DEBUG_THETA;
FETCH A, TEMP_ANGLE_16_HI;
STORE A, ANGLE_16_HI;
OUTPUT A, DEBUG_THETA;

LOAD R2,00; INITIALIZE SIGN INDICATOR REGISTER AS POSITIVE FOR BOTH SINE AND COSINE.

AND A,A; CLEAR THE BORROW (CARRY)

FETCH A, ANGLE_16_LO; PLACE LOWER BYTE OF ANGLE IN A
SUBCY A, 44; SUBTRACT LOWER BYTE BY PI/2
STORE A, ANGLE_16_LO; PLACE RESULT IN LOWER BYTE OF Z[0]
FETCH A, Z_0; PLACE UPPER BYTE OF ANGLE IN ACCUM
SUBCY A, 32; SUBT (WITH BORROW) UPPER BYTE OF PI
STORE A, Z_1; PLACE RESULT IN UPPER BYTE OF Z[0]
JUMP C,ADD_PIDIV2; IF BORROW SET, ANGLE WAS [0,PI/2]

; NOW CHECK IF THE ANGLE IS IN [PI/2,PI], IF NOT CONTINUE
LOAD R2,02; ;INITIALIZE SIGN INDICATOR REGISTER POSITIVE FOR SINE NEGATIVE FOR COSINE.
FETCH A,Z_0; PLACE LOWER BYTE OF ANGLE IN ACCUMULATOR
SUBCY A, 44; SUBTRACT LOWER BYTE BY PI/2
STORE A, Z_0; PLACE RESULT IN LOWER BYTE OF Z[0]
FETCH A, Z_1; PLACE UPPER BYTE OF ANGLE IN ACCUM.
SUBCY A, 32; SUBT WITH BORROW UPPER BYTE BY PI/2
STORE A, Z_1; PLACE RESULT IN UPPER BYTE OF Z[0]
JUMP C,TWOS; IF BORROW SET, ANGLE WAS IN [PI/2,PI)

;NOW CHECK IF THE ANGLE IS BETWEEN PI AND 3PI/2, IF NOT CONTINUE
LOAD R2,03; INITIALIZE SIGN INDICATOR REGISTER NEGATIVE FOR BOTH SINE AND COSINE
FETCH A, Z_0; PLACE LOWER BYTE OF ANGLE IN ACCUM.
SUBCY A, 44; SUBTRACT LOWER BYTE BY PI/2
STORE A, Z_0; PLACE RESULT IN LOWER BYTE OF Z[0]
FETCH A, Z_1; PLACE UPPER BYTE OF ANGLE IN ACCUM
SUBCY A, 32; SUBT (WITH BORROW) UPPER BYTE OF PI
STORE A, Z_1; PLACE RESULT IN UPPER BYTE OF Z[0]
JUMP C, ADD_PIDIV2; IF BORROW SET, ANGLE WAS IN [PI,3PI/2)

; IF WE GET THIS FAR, THE ANGLE IS BETWEEN 3PI/2 AND 2PI.
LOAD R2,01; INITIALIZE SIGN INDICATOR REGISTER POSITIVE FOR COSINE AND NEGATIVE FOR SINE
FETCH A,Z_0; PLACE LOWER BYTE OF ANGLE IN ACCUM
SUBCY A, 44; SUBTRACT LOWER BYTE BY PI/2
STORE A, Z_0; PLACE RESULT IN LOWER BYTE OF Z[0]
FETCH A, Z_1; PLACE UPPER BYTE OF ANGLE IN ACCUM
SUBCY A, 32; SUBT WITH BORROW UPPER BYTE BY PI/2
STORE A, Z_1; PLACE RESULT IN UPPER BYTE OF Z[0]

TWOS:
FETCH A, Z_0; FORM THE TWOS COMPARELEMENT OF Z[0]
XOR A, FF;
ADD A, 01;
STORE A, Z_0;
FETCH A, Z_1;
XOR A, FF;
ADDCY A, 00;
STORE A, Z_1;
JUMP CORDIC_ALGO;

ADD_PIDIV2: ; ADD BACK PI/2
FETCH A, Z_0;
ADD A, 44;
STORE A, Z_0;
FETCH A, Z_1;
ADDCY A, 32;
STORE A, Z_1;

; IT IS AT THIS POINT THAT THE CORDIC ALGORIYHM BEGINS
CORDIC_ALGO:
LOAD DPTR, E_00_START; INIT DATA POINTER AT CORDIC
LOAD R1, 00;
LOAD A, 00;
STORE A, K;

; BELOW IS THE CORDIC LOOP
CORDIC_LOOP:
FETCH R0,K; Temporarily store K for Shift_XY
FETCH A,X_0;
STORE A,XTMP_0; Temporarily store X[K]
FETCH A,X_1;
STORE A,XTMP_1;
FETCH A,Y_0;
STORE A,YTMP_0; Temporarily store Y[K]
FETCH A,Y_1;
STORE A,YTMP_1;

FETCH A,(DPTR); Temporarily store E[K]
STORE A,E_0;
ADD DPTR,01;
FETCH A,(DPTR);
STORE A,E_1;
ADD DPTR,01;
;ADD DPTR,01;

; SET UP THE CONTROL REGISTER, R3, THAT WILL CONTAIN INFO ON THE NEGATIVITY OF X[K], Y[K], AND Z[K]
LOAD R3,00;
FETCH A,X_1;
AND A,80;
SLA A;
OR A,R3;
LOAD R3,A;
FETCH A,Y_1;
AND A,80;
SLA A;
SLA A;
OR A,R3;
LOAD R3,A;
FETCH A,Z_1;
AND A,80;
SLA A;
SLA A;
SLA A;
OR A,R3;
LOAD R3,A;
ADD R3,01; THIS STEP REQUIRED FOR LATER DJNZ INSTRUCTIONS

; COMPAREUTE Z[K+1]
LOAD A,80;
FETCH s1,Z_1;
AND A,s1;
COMPARE A,00;
JUMP NZ,ADD_Z; TEST FOR NEGATIVE

FETCH A,E_0; FORM TWOS COMPLEMENT OF E[K] IF Z[K] IS POSITIVE, SINCE THEN A SUBTRACTION IS REQUIRED
XOR A,FF;
ADD A,01;
STORE A,E_0;
FETCH A,E_1;
XOR A,FF;
ADDCY A,00;
STORE A,E_1;

ADD_Z:
FETCH A,E_0;
FETCH s1,Z_0;
ADD A,s1;
STORE A,Z_0;
FETCH A,E_1;
FETCH s1,Z_1;
ADDCY A,s1;
STORE A,Z_1;

; COMPAREUTE X[K+1] AND Y[K+1]
CASE1:
SUB R3,01;
COMPARE R3,00;
JUMP NZ,CASE2;
CALL SHIFT_XY;
CALL TWOS_Y_SHIFTED;
JUMP ADD_XY;

CASE2:
SUB R3,01;
COMPARE R3,00;
JUMP NZ, CASE3;
CALL ABS_X;
CALL SHIFT_XY;
CALL TWOS_X_SHIFTED;
CALL TWOS_Y_SHIFTED
JUMP ADD_XY;

CASE3:
SUB R3,01;
COMPARE R3,00;
JUMP NZ, CASE4;
CALL ABS_Y;
CALL SHIFT_XY;
JUMP ADD_XY;

CASE4:
SUB R3,01;
COMPARE R3,00;
JUMP NZ,CASE5;
CALL ABS_X;
CALL ABS_Y;
CALL SHIFT_XY;
CALL TWOS_X_SHIFTED;
JUMP ADD_XY;

CASE5:
SUB R3,01;
COMPARE R3,00;
JUMP NZ,CASE6;
CALL SHIFT_XY;
CALL TWOS_X_SHIFTED;
JUMP ADD_XY;

CASE6:
SUB R3,01;
COMPARE R3,00;
JUMP NZ,CASE7;
CALL ABS_X;
CALL SHIFT_XY;
JUMP ADD_XY;

CASE7:
SUB R3,01;
COMPARE R3,00;
JUMP NZ,CASE8;
CALL ABS_Y;
CALL SHIFT_XY;
CALL TWOS_X_SHIFTED;
CALL TWOS_Y_SHIFTED;
JUMP ADD_XY;

CASE8:
CALL ABS_X;
CALL ABS_Y;
CALL SHIFT_XY;
CALL TWOS_Y_SHIFTED;

ADD_XY:
; FROM X[K+1]
FETCH A,YTMP_0;
FETCH s1,X_0;
ADD A,s1;
STORE A,X_0;
FETCH A,YTMP_1;
FETCH s1,X_1;
ADDCY A,s1;
STORE A,X_1;
; FROM Y[K+1]
FETCH A,XTMP_0;
FETCH s1,Y_0;
ADD A,s1;
STORE A,Y_0;
FETCH A,XTMP_1;
FETCH s1,Y_1;
ADDCY A,s1;
STORE A,Y_1;
; INCREMENT K AND TEST IF WE'VE LOOPED 14 TIMES YET
FETCH A,K;
ADD A,01;
STORE A,K;
ADD R1,01;
FETCH sF, E_00_LEN;
COMPARE R1, sF;
JUMP NZ,LONG_JUMP;
JUMP CORDIC_END;

LONG_JUMP:
JUMP CORDIC_LOOP;

CORDIC_END:
; IF THE COMPAREUTED ANSWER IS THE NEGATIVE OF THE TRUE ANSWER, TEST IF ANSWERS ARE NEGATIVE OR POSITIVE AND CHANGE SIGN.
LOAD A,03; LEAVE SIGN OF ANSWERS POSITIVE IF THE ANGLE IS [0,PI/2) OR R2 = 0
AND A,R2;
COMPARE A,00;
JUMP Z,THE_END;
; SKIP NEGATION OF COSINE IF ANGLE IS IN [3PI/2,2PI] OR R2 = 1
LOAD A,02;
AND A,R2;
COMPARE A, 00;
JUMP Z,TWOS_Y;

TWOS_X:
FETCH A,X_0; FORM THE TWOS COMPARELEMENT OF THE COSINE FOR ANGLES IN [PI/2, 3PI/2) OR R2 = 2 OR 3.
XOR A,FF;
ADD A,01;
STORE A,X_0;
FETCH A,X_1;
XOR A,FF;
ADDCY A,00;
STORE A,X_1;

TWOS_Y:
LOAD A,01; SKIP NEGATION OF SINE IF THE ANGLE IS IN [PI/2, PI)
AND A,R2;
COMPARE A, 00;
JUMP Z,THE_END;
FETCH A,Y_0; FORM THE TWOS COMPARELEMENT OF THE SINE FOR ANGLES IN [PI.2PI) OR EQUIVALENTLY, WHEN R2 = 1 OR 3.
XOR A,FF;
ADD A,01;
STORE A,Y_0;
FETCH A,Y_1;
XOR A,FF;
ADDCY A,00;
STORE A,Y_1;

THE_END:
JUMP THE_REAL_END;

ABS_X:
AND A,A;
FETCH A,XTMP_0;
SUBCY A,01;
STORE A,XTMP_0;
FETCH A,XTMP_1;
SUBCY A,00;
STORE A,XTMP_1;
RETURN;

ABS_Y:
AND A,A;
FETCH A,YTMP_0;
SUBCY A,01;
STORE A,YTMP_0;
FETCH A,YTMP_1;
SUBCY A,00;
STORE A,YTMP_1;
RETURN;

SHIFT_XY:
LOAD A, R0;
COMPARE A,00;
JUMP Z,END_SHIFT_XY;
SUB R0,01;
AND A,A;
FETCH A,XTMP_1;
SRX A; ???
STORE A,XTMP_1;
FETCH A,XTMP_0;
SRX A;
STORE A,XTMP_0;
AND A,A;
FETCH A,YTMP_1;
SRX A;
STORE A,YTMP_1;
FETCH A,YTMP_0;
SRX A;
STORE A,YTMP_0;
JUMP SHIFT_XY;

END_SHIFT_XY:
RETURN;

TWOS_X_SHIFTED:
FETCH A,XTMP_0;
XOR A,FF;
ADD A,01;
STORE A,XTMP_0;
FETCH A,XTMP_1;
XOR A,FF;
ADDCY A,00;
STORE A,XTMP_1;
RETURN;

TWOS_Y_SHIFTED:
FETCH A,YTMP_0;
XOR A,FF;
ADD A,01;
STORE A,YTMP_0;
FETCH A,YTMP_1;
XOR A,FF;
ADDCY A,00;
STORE A,YTMP_1;
RETURN;

THE_REAL_END:
FETCH A,X_0;
STORE A,COSINE_16_LO;
;OUTPUT A, DEBUG_COS;
FETCH A,X_1;
STORE A,COSINE_16_HI;
;OUTPUT A, DEBUG_COS;
FETCH A,Y_0;
STORE A,SINE_16_LO;
;OUTPUT A, DEBUG_SIN;
FETCH A,Y_1;
STORE A,SINE_16_HI;
;OUTPUT A, DEBUG_SIN;

FETCH A, COSINE_16_LO;
OUTPUT A, DEBUG_COS_1;
FETCH A, COSINE_16_HI;
OUTPUT A, DEBUG_COS_1;
FETCH A, COSINE_16_HI;
OUTPUT A, DEBUG_COS_2;
FETCH A, COSINE_16_LO;
OUTPUT A, DEBUG_COS_2;

FETCH A, SINE_16_LO;
OUTPUT A, DEBUG_SIN_1;
FETCH A, SINE_16_HI;
OUTPUT A, DEBUG_SIN_1;
FETCH A, SINE_16_HI;
OUTPUT A, DEBUG_SIN_2;
FETCH A, SINE_16_LO;
OUTPUT A, DEBUG_SIN_2;

RETURN;

FETCH s3, COSINE_16_LO;
FETCH s2, COSINE_16_HI;
LOAD s1, 03; FFFF/X_ROW
LOAD A, 33;
CALL divide_16;
;   s7,s6 - Q
;   s5,s4 - R
LOAD s3, 00;
LOAD s2, R1;
LOAD s1, 00;
LOAD A, 28;
CALL adder_16
STORE A, 3c;

FETCH s3, SINE_16_LO;
FETCH s2, SINE_16_HI;
LOAD s1, 03; FFFF/Y_COL
LOAD A, 33;
CALL divide_16;
;   s7,s6 - Q
;   s5,s4 - R
LOAD s3, 00;
LOAD s2, R1;
LOAD s1, 00;
LOAD A, 28;
CALL adder_16
STORE A, 3b;

FETCH A, 3c;
OUTPUT A, X_ROW; 
FETCH A, 3b;
OUTPUT A, Y_COL; 
LOAD A, 3F;
OUTPUT A, COLOR; 

JUMP main

USER_CODE_END:
JUMP USER_CODE_END;

subtract_16:
_subtract_16_start:               ;
                    SUB   A , s2 ;
                    SUBCY s1 , s3 ;
_subtract_16_end:                 ;
                    RETURN        ; 

adder_16:
_adder_16_start:                  ;
                  ADD    A , s2  ; add LSBs
                  ADDCY  s1 , s3  ; add MSBs
_adder_16_end:                    ;
                  RETURN          ; keep result in x_msb and tmp

divide_16:
_divide_16_start:                               ;
                  LOAD    R2 , s3               ; R := N
                  LOAD    R3 , s2               ;
                  LOAD    R0 , 00               ; Q := 0
                  LOAD    R1 , 00               ;
_divide_16_loop:                                ;
                  COMPARE R3 , A               ; while R >= D do
                  SUBCY   s1 , 00               ;
                  COMPARE R2 , s1               ;
                  JUMP     C , _divide_16_end   ; <
                  SUB     R3 , A               ; R := R − D
                  SUBCY   R2 , s1               ;
                  ADD     R1 , 01               ; Q := Q + 1
                  ADDCY   R0 , 00               ;
                  JUMP         _divide_16_loop  ;
_divide_16_end:                                 ;
                  RETURN                        ;

compare_16:
_compare_16_start:                                      ;
                      COMPARE s3 , s1                   ;
                      JUMP     C , _compare_16_less     ;
                      JUMP     Z , _compare_16_equal_hi ;
                      JUMP         _compare_16_more     ;
_compare_16_equal_hi:                                   ;
                      COMPARE s2 , A                   ;
                      JUMP     C , _compare_16_less     ;
                      JUMP    NZ , _compare_16_more     ;
                      JUMP         _compare_16_equal    ;
_compare_16_less:                                       ; s3,s2 < s1,s0
                      LOAD    R3 , 01                   ;
                      JUMP         _compare_16_end      ;
_compare_16_equal:                                      ; s3,s2 = s1,s0
                      LOAD    R3 , 02                   ;
                      JUMP         _compare_16_end      ;
_compare_16_more:                                       ; s3,s2 > s1,s0
                      LOAD    R3 , 04                   ;
_compare_16_end:                                        ;
                      RETURN                            ;

