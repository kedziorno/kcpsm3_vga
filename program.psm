CONSTANT X_ROW, 16;
CONSTANT Y_COL, 17;
CONSTANT COLOR, 20;

;Name the registers - alias
NAMEREG s0, tmp
NAMEREG s1, x_msb
NAMEREG s2, x_lsb
NAMEREG s3, y_msb
NAMEREG s4, y_lsb
NAMEREG s5, z_msb
NAMEREG s6, z_lsb
NAMEREG s7, LUT_pnt
NAMEREG s8, tmp_H
NAMEREG s9, tmp_L
NAMEREG sA, tmp_H2
NAMEREG sB, tmp_L2
NAMEREG sC, i
NAMEREG sD, k
NAMEREG sE, temp_z_lsb
NAMEREG sF, temp_z_msb

;Declare Constant
;CONSTANT inPrt_H, 01
;CONSTANT inPrt_L, 02
;CONSTANT prtX_H, 04
;CONSTANT prtX_L, 08
;CONSTANT prtY_H, 10
;CONSTANT prtY_L, 20
CONSTANT DEBUG_SIN, 01
CONSTANT DEBUG_COS, 02
CONSTANT DEBUG_THETA, 03

CONSTANT c_x_lsb, 3f
CONSTANT c_x_msb, 3e
CONSTANT c_y_lsb, 3d
CONSTANT c_y_msb, 3c

CONSTANT testPort, 40
CONSTANT NEG_SGN, 80
CONSTANT EIGHT, 08
CONSTANT NINE, 09
CONSTANT ONE, 01
CONSTANT ZERO, 00

; make_cordic_params.py `echo "(180/3.1415)*256" | bc -l` 16 1
; make_cordic_params.py 58 8 1
; 1rad ~ 57.324840 (180/3.14.15)
; 1rad * 256
;Scratchpad RAM initalize
;use Reg tmp for load and store values
LOAD tmp,  00 ;LUT: 0.605469_msb
STORE tmp, 00 ;loc
LOAD tmp,  9B ;LUT: 0.605469_lsb
STORE tmp, 01 ;loc

LOAD tmp,  2D ;LUT: 45.000000 msb
STORE tmp, 02 ;loc
LOAD tmp,  00 ;LUT: 45.000000_lsb
STORE tmp, 03 ;loc

LOAD tmp,  1A ;LUT: 26.5625_msb
STORE tmp, 04 ;loc
LOAD tmp,  90 ;LUT: 26.5625_lsb
STORE tmp, 05 ;loc

LOAD tmp,  0E ;LUT: 14.035156_msb
STORE tmp, 06 ;loc
LOAD tmp,  09 ;LUT: 14.035156_lsb
STORE tmp, 07 ;loc

LOAD tmp,  07 ;LUT: 7.125000_msb
STORE tmp, 08 ;loc
LOAD tmp,  20 ;LUT: 7.125000_lsb
STORE tmp, 09 ;loc

LOAD tmp,  03 ;LUT: 3.574219_msb
STORE tmp, 0A ;loc
LOAD tmp,  93 ;LUT: 3.574219_lsb
STORE tmp, 0B ;loc

LOAD tmp,  01 ;LUT: 1.792969_msb
STORE tmp, 0C ;loc
LOAD tmp,  CB ;LUT: 1.792969_lsb
STORE tmp, 0D ;loc

LOAD tmp,  00 ;LUT: 0.894531_msb
STORE tmp, 0E ;loc
LOAD tmp,  E5 ;LUT: 0.894531_lsb
STORE tmp, 0F ;loc

LOAD tmp,  00 ;LUT: 0.445313_msb
STORE tmp, 10 ;loc
LOAD tmp,  72 ;LUT: 0.445313_lsb
STORE tmp, 11 ;loc

LOAD tmp,  00 ;LUT: 0.226563_msb
STORE tmp, 12 ;loc
LOAD tmp,  3A ;LUT: 0.226563_lsb
STORE tmp, 13 ;loc

LOAD temp_z_msb, 00
LOAD temp_z_lsb, 00

loop:
;Input the rotation value from FPGA MUXes
ADD temp_z_lsb, ff
ADDCY temp_z_msb, 00

OUTPUT temp_z_lsb, DEBUG_THETA
OUTPUT temp_z_msb, DEBUG_THETA

; error correction
;COMPARE z_msb, 5A
;JUMP Z, case_90

;COMPARE z_msb, 00
;JUMP Z, case_0

init:
;initialize registers
LOAD LUT_pnt, 00
FETCH x_msb, (LUT_pnt)

ADD LUT_pnt, 01
FETCH x_lsb, (LUT_pnt)

LOAD i, FF

LOAD z_lsb, temp_z_lsb
LOAD z_msb, temp_z_msb

next1:

;OUTPUT z_lsb, DEBUG_THETA
;OUTPUT z_msb, DEBUG_THETA

ADD i, 01
;OUTPUT i, testPort

;prepare registers for subroutines
LOAD tmp_H, x_msb
LOAD tmp_L, x_lsb
LOAD tmp_H2, y_msb
LOAD tmp_L2, y_lsb

LOAD k, i

shift:
COMPARE k, ZERO
JUMP  Z, next2

;divide by 2 (shift one to the right)
SRX tmp_H
SRA tmp_L
SRX tmp_H2
SRA tmp_L2

SUB k, 01
JUMP shift

next2:
COMPARE i, NINE
JUMP Z, out_rslt

;check rotation sign
LOAD tmp, z_msb
AND tmp, NEG_SGN

;COMPARE z msb with NEG SGN- -
;TEST tmp, NEG_SGN
JUMP NZ, neg_case

;else Z_msb is positive--> continue

pos_case:
;X[i=O]
SUB x_lsb, tmp_L2
SUBCY x_msb, tmp_H2

;Y[i=O]
ADD y_lsb, tmp_L
ADDCY y_msb, tmp_H

;Z[i+l]
ADD LUT_pnt, 01
FETCH tmp_H, (LUT_pnt)
ADD LUT_pnt, 01
FETCH tmp_L,(LUT_pnt)
SUB z_lsb, tmp_L
SUBCY z_msb, tmp_H

JUMP next1

neg_case:

;X[i=O]
ADD x_lsb, tmp_L2
ADDCY x_msb, tmp_H2

;Y[i=O]
SUB y_lsb, tmp_L
SUBCY y_msb, tmp_H

;Z[i+l]
ADD LUT_pnt, 01
FETCH tmp_H, (LUT_pnt)
ADD LUT_pnt, 01
FETCH tmp_L,(LUT_pnt)
ADD z_lsb, tmp_L
ADDCY z_msb, tmp_H

JUMP next1

case_0:
LOAD x_msb, 01
LOAD x_lsb, 00
LOAD y_msb, 00
LOAD y_lsb, 00
JUMP out_rslt

case_90:
LOAD x_msb, 00
LOAD x_lsb, 00
LOAD y_msb, 01
LOAD y_lsb, 00
JUMP out_rslt
 
out_rslt:
STORE x_lsb, c_x_lsb
STORE x_msb, c_x_msb
STORE y_lsb, c_y_lsb
STORE y_msb, c_y_msb

FETCH y_msb, c_x_msb;
FETCH x_lsb, c_x_lsb;
OUTPUT x_lsb, DEBUG_COS;
OUTPUT y_msb, DEBUG_COS;
LOAD x_msb, 00; FFFF/X_ROW
LOAD tmp, 04;
CALL divide_16;
;   s7,s6 - Q
;   s5,s4 - R
LOAD y_msb, 00;
LOAD x_lsb, z_lsb;
LOAD x_msb, 00;
LOAD tmp, 28;
CALL adder_16
STORE tmp, 3c;

FETCH y_msb, c_y_msb;
FETCH x_lsb, c_y_lsb;
OUTPUT x_lsb, DEBUG_SIN;
OUTPUT y_msb, DEBUG_SIN;
LOAD x_msb, 00; FFFF/Y_COL
LOAD tmp, 04;
CALL divide_16;
;   s7,s6 - Q
;   s5,s4 - R
LOAD y_msb, 00;
LOAD x_lsb, z_lsb;
LOAD x_msb, 00;
LOAD tmp, 28;
CALL adder_16
STORE tmp, 3b;

FETCH tmp, 3c;
OUTPUT tmp, X_ROW; 
FETCH tmp, 3b;
OUTPUT tmp, Y_COL; 
LOAD tmp, 3F;
OUTPUT tmp, COLOR; 

JUMP loop

adder_16:
_adder_16_start:                  ;
                  ADD    tmp , x_lsb  ; add LSBs
                  ADDCY  x_msb , y_msb  ; add MSBs
_adder_16_end:                    ;
                  RETURN          ; keep result in x_msb and tmp

divide_16:
_divide_16_start:                               ;
                  LOAD    z_msb , y_msb               ; R := N
                  LOAD    y_lsb , x_lsb               ;
                  LOAD    LUT_pnt , 00               ; Q := 0
                  LOAD    z_lsb , 00               ;
_divide_16_loop:
                  COMPARE y_lsb , tmp               ; while R >= D do
                  SUBCY   x_msb , 00               ;
                  COMPARE z_msb , x_msb               ;
                  JUMP     C , _divide_16_end   ; <
                  SUB     y_lsb , tmp               ; R := R âˆ’ D
                  SUBCY   z_msb , x_msb               ;
                  ADD     z_lsb , 01               ; Q := Q + 1
                  ADDCY   LUT_pnt , 00               ;
                  JUMP         _divide_16_loop  ;
_divide_16_end:                                 ;
                  RETURN                        ;

